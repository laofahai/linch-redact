# Linch Redact 扩展平台详细设计方案 (V3.0 - 纯描述版)

**文档版本:** 3.0
**状态:** `方案拟定`
**核心宗旨:** 本文档使用纯粹的、详尽的中文文字描述，旨在为 `Linch Redact` 的平台化升级提供一份清晰、具体且可执行的设计蓝图。它深度融合了项目的战略目标（抽象层面）与具体实现机制（具体层面），作为后续开发工作的最终依据。

---

## 第一章：项目目标与核心问题

### 1.1. 我们要解决什么问题？

当前版本的 `Linch Redact` 存在两大核心局限，阻碍了其成为一个真正强大的工具：

1.  **格式的单一性**：工具目前仅能处理 PDF 文件。然而在真实世界中，大量的敏感信息存在于 Word 文稿、Markdown 笔记、纯文本文档等多种载体中。这种能力的缺失，使得 `Linch Redact` 在许多场景下无用武之地。
2.  **规则的浅薄性**：目前的脱敏逻辑主要依赖于格式固定的正则表达式。这对于识别电话号码、邮箱等非常有效，但对于像中文姓名、地址、机构名称等无固定格式、需要结合上下文判断的复杂信息，则显得力不从心，容易漏报或误报。

### 1.2. 本次升级要实现的具体功能

为解决上述问题，本次升级将交付一个功能截然不同的新版本，它将具备以下能力：

- **支持多种文档格式**：除了现有的 PDF，新版本将至少支持对纯文本 (`.txt`)、Markdown (`.md`) 和微软 Word (`.docx`) 文件的脱敏处理。
- **全新的智能规则引擎**：用户将能够使用远超正则表达式的、更强大的规则来进行脱敏，包括：
  - **基于“名单”的匹配**（词典规则）：例如，导入一份员工名单，自动脱敏文档中出现的所有姓名。
  - **基于“算法逻辑”的匹配**（启发式规则）：例如，启用“地址识别”功能，系统将能自动发现并脱敏那些看起来像地址的文本段落。
- **可管理的内置规则**：系统将提供一套高质量的、不可删除的内置规则（如身份证、邮箱），同时允许用户创建、修改和删除自己的专属规则。
- **高度自适应的用户界面**：软件界面将能“感知”当前正在处理的文件类型，并动态地展示出最合适的功能选项与预览效果。

### 1.3. 贯穿整个设计的核心原则

在实现上述功能时，我们将遵循以下几条务实的设计原则：

1.  **模块化**：每一个独立的功能（如PDF处理、Word处理、规则匹配）都应该被封装在自己的“盒子”里，做到“自己的事自己管”，减少互相依赖，方便单独升级和测试。
2.  **可扩展性**：今天的架构必须为明天做准备。在未来，当我们想增加对 `.epub` 或 `.html` 文件的支持时，整个过程应该像“即插即用”的USB设备一样简单，而不是对整个系统进行“大手术”。
3.  **直观易用**：无论背后技术多复杂，呈现给用户的界面必须是简洁的、符合直觉的。系统应主动帮助用户规避错误，而不是让用户去记忆复杂的操作手册。

---

## 第二章：系统整体设计

### 2.1. 核心思路：建立“标准化作业流程”

要让系统能够处理多种完全不同的文件格式，核心在于建立一套所有“文件处理器”都必须遵守的“标准化作业流程”。

**问题：** 如果我们为 PDF 写一套逻辑，再为 Word 写另一套完全独立的逻辑，很快就会陷入混乱。两套逻辑中可能有大量重复的部分（如读取文件、保存文件），而且主程序需要写很多 `if...else...` 来判断当前到底该调用谁，一旦增加新格式，就要继续增加判断，这被称为“硬编码”，是软件工程的灾难。

**解决方案：** 我们将定义一个名为 **“统一文档接口”** 的标准化契约。它不关心任何具体的文件格式，只规定了一套标准的“任务清单”。任何文件处理器，无论它多么特立独行，都必须向系统证明自己能够完成这份清单上的所有任务。

这样一来，主程序就从一个事必躬亲的“小工头”，升级成了一个只负责监督标准流程的“大项目经理”。它只需对任何一个文件处理器说：“请按标准流程，执行第一步、第二步、第三步...”，而无需关心这个处理器内部是如何使用自己独特的工具（如PDF解析库或Word解析库）来完成这些任务的。

### 2.2. 系统核心组件

整个系统将由以下几个核心组件构成，它们协同工作，完成脱敏任务：

1.  **前端用户界面 (Frontend)**：用户直接交互的所有窗口、按钮、面板的总和。它完全使用网页技术（React）构建。
2.  **后端服务引擎 (Backend)**：在后台运行的、负责所有实际工作的“发动机”。它使用高性能的 Rust 语言编写。
3.  **Tauri 通信桥梁 (API Layer)**：一个专门的“信使”，负责在前端界面和后端引擎之间准确、高效地传递指令和数据。例如，当用户点击“开始脱敏”按钮时，前端就通过这位“信使”向后端发送一条“请执行脱敏”的指令。

### 2.3. 用户操作下的数据流转过程

设想一个完整的操作流程，以理解各组件如何协作：

1.  **文件拖入**：用户将一份 `.docx` 文件拖入到 `Linch Redact` 的窗口中。
2.  **指令发出**：前端界面捕获到这个动作，立刻通过“Tauri信使”向后端发送一条指令，内容是：“收到一个新文件，路径是 ‘C:/Users/.../report.docx’，请加载它。”
3.  **后端分发**：后端的“总指挥部”收到指令，看到文件扩展名是 `.docx`，于是它从工具箱里拿出“Word文档处理器”，并对它说：“有一个任务给你，这是文件路径。”
4.  **文件处理**：
    - “Word文档处理器”开始工作，它使用专门的工具（`docx-rs`库）打开并解析这个Word文件。
    - 它按照“统一文档接口”的要求，将文档中所有文字提取出来，整理成一个“页面列表”（对于Word，通常只有一个很长的页面）。
    - 处理器同时还会附上一份“能力清单”，告诉总指挥部：“我是一个Word处理器，我支持‘文本脱敏’，但不支持‘元数据清理’。”
5.  **数据回传**：“总指挥部”将处理好的页面文本、文件的基本信息、以及“能力清单”，一并打包，通过“Tauri信使”送回到前端。
6.  **界面响应**：前端的“信息中心”收到这份大数据包后，立刻通知所有UI组件进行更新：
    - 预览区组件收到文本，立刻将其显示出来。
    - 侧边栏组件收到“能力清单”，发现其中没有“元数据清理”，于是它就很聪明地将“清理元数据”那个开关选项隐藏起来。
7.  **完成加载**：至此，文件加载和界面响应完成，用户看到了一个为处理Word文档而“量身定制”的界面，整个过程在1-2秒内完成。

---

## 第三章：后端具体实现机制（纯文字描述）

### 3.1. 核心数据结构与接口的详尽描述

#### 3.1.1. “统一文档接口”的详尽描述

这是一个抽象的、概念性的“接口”，是所有文件处理器的“资格认证标准”。它规定了以下几项必须完成的“任务”：

- **任务一：加载 (load)**
  - **职责**：负责将一个给定的文件路径，转换为一个可以在内存中被操作的“文档对象”。
  - **输入**：一个字符串，代表文件的完整磁盘路径。
  - **过程**：处理器内部需要完成文件的读取、格式的校验、以及初步的解析。
  - **输出**：一个代表该文档的、已加载到内存中的“对象实例”。
  - **异常处理**：必须能够处理各种加载失败的情况，并返回明确的错误信息，例如：文件不存在、文件被密码锁定、文件格式已损坏等。

- **任务二：提取页面文本 (get_pages)**
  - **职责**：从已加载的“文档对象”中，抽取出所有可供脱敏的纯文本，并进行结构化组织。
  - **输入**：无（操作的是已加载的文档对象自身）。
  - **过程**：这是格式处理的核心。例如，PDF处理器需要逐页扫描，合并文字块；Word处理器需要遍历段落、表格。
  - **输出**：一个“页面”列表。每个“页面”都是一个独立的数据单元，它至少包含两个信息：
    1.  `页码` (一个数字，从1开始)。
    2.  `页面文本内容` (一个长字符串，包含该页所有的纯文本)。
        对于 `.txt` 这种无分页概念的，整个文件内容就作为页码为1的唯一“页面”返回。

- **任务三：执行脱敏 (redact)**
  - **职责**：接收一份“脱敏方案”（即匹配到的所有需要屏蔽的文本和规则），并将其应用到文档上，生成最终的、安全的、已脱敏的文件内容。
  - **输入**：一个“规则集合”，详细说明了哪些文本片段需要被替换成什么内容。
  - **过程**：处理器需要根据自己的格式特点来完成替换。纯文本是简单的字符串替换，而Word处理器则需要调用专门的库函数，在不破坏 `document.xml` 结构和样式的前提下，安全地替换文字。
  - **输出**：一段二进制数据（字节流），这代表了整个已被脱敏的新文件的内容。之所以是二进制，是因为像PDF、Word等文件本质上都是二进制格式。

- **任务四：声明能力 (get_supported_features)**
  - **职责**：向主程序报告自己除了基本的文本脱敏外，还支持哪些“高级玩法”。
  - **输入**：无。
  - **输出**：一个字符串列表。例如，PDF处理器可能会返回 `["文本脱敏", "元数据清理"]`，而纯文本处理器只会返回 `["文本脱敏"]`。这个列表是驱动前端动态UI的关键依据。

#### 3.1.2. “规则”数据结构的详尽描述

系统中的每一条“脱敏规则”都是一个结构化的数据单元，它由以下几个部分构成：

- **唯一ID (id)**：一个绝不重复的内部身份证号，用于精确地识别和管理每一条规则。
- **规则名称 (name)**：一个用户可读的友好名称，如“邮箱地址”或“我的员工名单”。
- **启用状态 (enabled)**：一个开关（是/否），决定了在本次脱敏任务中，是否要激活并使用这条规则。
- **系统规则标记 (is_system)**：一个开关（是/否），用于区分是系统内置的规则，还是用户自己创建的。UI将根据此标记决定是否允许用户删除或修改该规则。
- **规则类型 (rule_type)**：这是规则的核心，它定义了这条规则“如何工作”。它本身又是一个复合结构，包含“类型名称”和“类型数据”两部分。
  - **类型一：正则表达式**
    - **类型名称**: `Regex`
    - **类型数据**: 包含一个字符串，即正则表达式的匹配模式。
  - **类型二：词典**
    - **类型名称**: `Dictionary`
    - **类型数据**: 包含一个字符串列表，即所有需要匹配的关键词（如人名列表）。
  - **类型三：启发式算法**
    - **类型名称**: `Heuristic`
    - **类型数据**: 包含一个枚举值，指明要使用哪一种内置的启发式算法，如 `Address` (地址识别算法) 或 `PersonName` (人名识别算法)。

### 3.2. 各文件处理器的工作机制

- **PDF 处理器**：将重度依赖一个名为 `pdfium` 的底层库。`加载`时会初始化这个库，`提取文本`时会调用库的函数逐页进行文本抽取，`执行脱敏`时，则需要先在文本层找到坐标，再通过绘制一个不透明的黑色矩形来“覆盖”掉原文。
- **纯文本/Markdown 处理器**：这两个最为简单。`加载`就是把整个文件读成一个大字符串。`提取文本`就是把这个字符串包装成一个“页面”。`执行脱敏`就是在这个大字符串上进行查找和替换。
- **Word 处理器**：将依赖一个名为 `docx-rs` 的库。它的难点在于`执行脱敏`。它不能简单粗暴地替换文本，因为Word文档的文字和样式是分开存储在复杂的XML结构中的。它必须通过库提供的安全接口，找到对应的文本节点，只替换文字内容，而不触碰任何与字体、颜色、大小等相关的样式标签。

---

## 第四章：前端具体实现机制（纯文字描述）

### 4.1. 核心状态管理机制

前端将设立一个全局的“信息中心”（`Zustand Store`），专门用于存放与当前任务相关的所有状态信息。这个信息中心将包含以下几个关键的“数据抽屉”：

- **`currentFile` 抽屉**：用于存放当前已加载文件的所有信息。如果为“空”，则表示当前无任务。如果不为空，则里面会存放一个包含文件所有细节的对象，包括：`路径`、`文件名`、`文件类型`（pdf, word等）、一个包含所有`页面`文本的列表、`总页数`、以及该文件支持的`能力列表`。
- **`isLoading` 抽屉**：存放一个开关（是/否），用于表示应用当前是否正在执行一个耗时的后台任务（如加载大文件）。UI会根据这个开关的状态，来决定是否要显示一个“加载中”的动画，并临时禁用某些按钮。
- **`error` 抽屉**：用于存放上一步操作发生的错误信息。如果为“空”，则一切正常。如果不为空，则存放着一段用户可读的友好错误提示。UI会监听这个抽屉，一旦有内容，就立即弹出一个醒目的错误提示框。

### 4.2. 关键组件的设计与职责

- **`FileDropzone` (文件拖放区)**：这是用户与应用交互的起点。它的职责是监听用户的拖放和点击选择文件的动作，获取到文件路径后，立即通知“信息中心”开始执行`openFile`（打开文件）的流程。
- **`PreviewPane` (动态预览面板)**：这是一个“智能容器”。它唯一的职责就是观察“信息中心”里 `currentFile` 抽屉中的`文件类型`。根据类型的不同，它会自动在内部“召唤”出不同的预览子组件（PDF预览器、Markdown渲染器或纯文本显示框），并把文件内容数据传递给它们去展示。
- **`RulePanel` (规则配置面板)**：这同样是一个“智能容器”。它会观察 `currentFile` 的`能力列表`。它内部的各个功能开关（如“元数据清理”）都有自己的“身份标签”，只有当`能力列表`中包含自己的标签时，它们才会显示出来，否则就保持隐藏。

---

## 第五章：详细的、分阶段的实施步骤

我们将严格按照以下四个阶段，一步一个脚印地完成开发。

- **第一阶段：奠定后端基石**
  - **目标**：完成后端最核心的、与具体格式无关的架构改造。
  - **步骤**：
    1.  在 `crates/core` 模块中，用详尽的文字描述（如本章3.1节所示）在内部文档中定义好“统一文档接口”和“规则”的数据结构。
    2.  将现有的PDF处理代码进行“伤筋动骨”的重构，使其严格按照新的“文档接口”标准来工作。
    3.  创建一个全新的、极其简单的 `text` 处理器模块，作为新架构的“第一个客户”，并让它成功实现“文档接口”。
    4.  在主程序中，搭建起能够根据文件扩展名，自动选择并调用不同处理器的“命令分发器”逻辑。
  - **产出**：一个虽然功能尚不完整，但架构已焕然一新的后端。它能够通过同一套指令，处理PDF和TXT两种文件。

- **第二阶段：贯通前后端，支持基础格式**
  - **目标**：打通前后端的数据流，让用户能在界面上真实地体验到处理TXT和MD文件的完整流程。
  - **步骤**：
    1.  按照4.1节的描述，彻底改造前端的“信息中心”，使其能够容纳新架构下的数据。
    2.  重写前端的文件加载逻辑，使其调用新的后端“加载”指令。
    3.  实现前端的“动态预览面板”，并为其配备纯文本和Markdown两种预览组件。
  - **产出**：用户可以拖入TXT或MD文件，看到预览，并使用简单的规则完成脱敏。

- **第三阶段：构建智能引擎，攻克Word**
  - **目标**：完成高级规则引擎的开发，并拿下Word支持这个硬骨头。
  - **步骤**：
    1.  在后端，实现对“词典规则”和“启发式规则”的匹配算法。
    2.  在后端，实现“系统规则”与“用户规则”的区分和加载机制。
    3.  在前端，开发全新的“规则配置工作台”界面。
    4.  在后端，创建`word`处理器模块，投入主要精力研究并实现安全、可靠的Word文本替换。
  - **产出**：一个具备“智能”脱敏能力，且能处理主流商业文档格式的强大版本。

- **第四阶段：全面打磨，确保品质**
  - **目标**：修复所有已知问题，优化性能，完善体验，达到可交付状态。
  - **步骤**：
    1.  对所有界面交互进行地毯式检查和优化。
    2.  对大文件加载、复杂规则匹配等场景进行专项性能测试和优化。
    3.  补充自动化测试用例，确保软件的长期稳定。
    4.  完善所有的用户提示文案和帮助文档。
  - **产出**：一个稳定、流畅、可靠的 `Linch Redact` v2.0 正式版。
